"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiEntrypoint = exports.transformPush = exports.getDestinationProps = exports.handlePush = void 0;
const fs = require("fs");
const path = require("path");
const node_fetch_1 = require("node-fetch");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
const crypto_1 = require("crypto");
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const login_1 = require("./login");
const DEFAULT_VERSION = 'latest';
function handlePush(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield openapi_core_1.loadConfig();
        const region = argv.region || config.region;
        const client = new openapi_core_1.RedoclyClient(region);
        const isAuthorized = yield client.isAuthorizedWithRedoclyByRegion();
        if (!isAuthorized) {
            const clientToken = yield login_1.promptClientToken(client.domain);
            yield client.login(clientToken);
        }
        const startedAt = perf_hooks_1.performance.now();
        const { destination, branchName, upsert } = argv;
        if (destination &&
            !(validateDestination(destination) || validateDestinationWithoutOrganization(destination))) {
            utils_1.exitWithError(`Destination argument value is not valid, please use the right format: ${colorette_1.yellow('<@organization-id/api-name@api-version>')}`);
        }
        const [organizationId, name, version] = getDestinationProps(destination, config.organization);
        if (!organizationId) {
            return utils_1.exitWithError(`No organization provided, please use the right format: ${colorette_1.yellow('<@organization-id/api-name@api-version>')} or specify the 'organization' field in the config file.`);
        }
        const entrypoint = argv.entrypoint || (name && version && getApiEntrypoint({ name, version, config }));
        if (name && version && !entrypoint) {
            utils_1.exitWithError(`No entrypoint found that matches ${colorette_1.blue(`${name}@${version}`)}. Please make sure you have provided the correct data in the config file.`);
        }
        const apis = entrypoint ? { [`${name}@${version}`]: { root: entrypoint } } : config.apis;
        for (const [apiNameAndVersion, { root: entrypoint }] of Object.entries(apis)) {
            const resolvedConfig = openapi_core_1.getMergedConfig(config, apiNameAndVersion);
            resolvedConfig.lint.skipDecorators(argv['skip-decorator']);
            const [name, version = DEFAULT_VERSION] = apiNameAndVersion.split('@');
            try {
                let rootFilePath = '';
                const filePaths = [];
                const filesToUpload = yield collectFilesToUpload(entrypoint, resolvedConfig);
                const filesHash = hashFiles(filesToUpload.files);
                process.stdout.write(`Uploading ${filesToUpload.files.length} ${utils_1.pluralize('file', filesToUpload.files.length)}:\n`);
                let uploaded = 0;
                for (let file of filesToUpload.files) {
                    const { signedUploadUrl, filePath } = yield client.registryApi.prepareFileUpload({
                        organizationId,
                        name,
                        version,
                        filesHash,
                        filename: file.keyOnS3,
                        isUpsert: upsert,
                    });
                    if (file.filePath === filesToUpload.root) {
                        rootFilePath = filePath;
                    }
                    filePaths.push(filePath);
                    process.stdout.write(`Uploading ${file.contents ? 'bundle for ' : ''}${colorette_1.blue(file.filePath)}...`);
                    const uploadResponse = yield uploadFileToS3(signedUploadUrl, file.contents || file.filePath);
                    const fileCounter = `(${++uploaded}/${filesToUpload.files.length})`;
                    if (!uploadResponse.ok) {
                        utils_1.exitWithError(`✗ ${fileCounter}\nFile upload failed\n`);
                    }
                    process.stdout.write(colorette_1.green(`✓ ${fileCounter}\n`));
                }
                process.stdout.write('\n');
                yield client.registryApi.pushApi({
                    organizationId,
                    name,
                    version,
                    rootFilePath,
                    filePaths,
                    branch: branchName,
                    isUpsert: upsert,
                });
            }
            catch (error) {
                if (error.message === 'ORGANIZATION_NOT_FOUND') {
                    utils_1.exitWithError(`Organization ${colorette_1.blue(organizationId)} not found`);
                }
                if (error.message === 'API_VERSION_NOT_FOUND') {
                    utils_1.exitWithError(`The definition version ${colorette_1.blue(name)}/${colorette_1.blue(version)} does not exist in organization ${colorette_1.blue(organizationId)}!\n${colorette_1.yellow('Suggestion:')} please use ${colorette_1.blue('-u')} or ${colorette_1.blue('--upsert')} to create definition.
        `);
                }
                throw error;
            }
            process.stdout.write(`Definition: ${colorette_1.blue(entrypoint)} is successfully pushed to Redocly API Registry \n`);
        }
        utils_1.printExecutionTime('push', startedAt, entrypoint || `apis in organization ${organizationId}`);
    });
}
exports.handlePush = handlePush;
function getFilesList(dir, files) {
    files = files || [];
    const filesAndDirs = fs.readdirSync(dir);
    for (const name of filesAndDirs) {
        if (fs.statSync(path.join(dir, name)).isDirectory()) {
            files = getFilesList(path.join(dir, name), files);
        }
        else {
            const currentPath = dir + '/' + name;
            files.push(currentPath);
        }
    }
    return files;
}
function collectFilesToUpload(entrypoint, config) {
    return __awaiter(this, void 0, void 0, function* () {
        let files = [];
        const [{ path: entrypointPath }] = yield utils_1.getFallbackEntryPointsOrExit([entrypoint], config);
        process.stdout.write('Bundling definition\n');
        const { bundle: openapiBundle, problems } = yield openapi_core_1.bundle({
            config,
            ref: entrypointPath,
            skipRedoclyRegistryRefs: true,
        });
        const fileTotals = openapi_core_1.getTotals(problems);
        if (fileTotals.errors === 0) {
            process.stdout.write(`Created a bundle for ${colorette_1.blue(entrypoint)} ${fileTotals.warnings > 0 ? 'with warnings' : ''}\n`);
        }
        else {
            utils_1.exitWithError(`Failed to create a bundle for ${colorette_1.blue(entrypoint)}\n`);
        }
        const fileExt = path.extname(entrypointPath).split('.').pop();
        files.push(getFileEntry(entrypointPath, utils_1.dumpBundle(openapiBundle.parsed, fileExt)));
        if (fs.existsSync('package.json')) {
            files.push(getFileEntry('package.json'));
        }
        if (fs.existsSync(openapi_core_1.IGNORE_FILE)) {
            files.push(getFileEntry(openapi_core_1.IGNORE_FILE));
        }
        if (config.configFile) {
            // All config file paths including the root one
            files.push(...[...new Set(config.lint.extendPaths)].map((f) => getFileEntry(f)));
            if (config['features.openapi'].htmlTemplate) {
                const dir = getFolder(config['features.openapi'].htmlTemplate);
                const fileList = getFilesList(dir, []);
                files.push(...fileList.map((f) => getFileEntry(f)));
            }
            let pluginFiles = new Set();
            for (const plugin of config.lint.pluginPaths) {
                if (typeof plugin !== 'string')
                    continue;
                const fileList = getFilesList(getFolder(plugin), []);
                fileList.forEach((f) => pluginFiles.add(f));
            }
            files.push(...filterPluginFilesByExt(Array.from(pluginFiles)).map((f) => getFileEntry(f)));
        }
        return {
            files,
            root: path.resolve(entrypointPath),
        };
        function filterPluginFilesByExt(files) {
            return files.filter((file) => {
                const fileExt = path.extname(file).toLowerCase();
                return fileExt === '.js' || fileExt === '.ts' || fileExt === '.mjs' || fileExt === 'json';
            });
        }
        function getFileEntry(filename, contents) {
            return {
                filePath: path.resolve(filename),
                keyOnS3: config.configFile
                    ? openapi_core_1.slash(path.relative(path.dirname(config.configFile), filename))
                    : openapi_core_1.slash(path.basename(filename)),
                contents: (contents && Buffer.from(contents, 'utf-8')) || undefined,
            };
        }
    });
}
function getFolder(filePath) {
    return path.resolve(path.dirname(filePath));
}
function hashFiles(filePaths) {
    let sum = crypto_1.createHash('sha256');
    filePaths.forEach((file) => sum.update(fs.readFileSync(file.filePath)));
    return sum.digest('hex');
}
function validateDestination(destination) {
    const regexp = /^@+([a-zA-Z0-9-_.& ]+)\/+([^@\/]+)@([^@\/]+)$/;
    return regexp.test(destination);
}
function validateDestinationWithoutOrganization(destination) {
    const regexp = /^()([^@\/]+)@([^@\/]+)$/;
    return regexp.test(destination);
}
function getDestinationProps(destination, organization) {
    return destination && validateDestination(destination)
        ? destination.substring(1).split(/[@\/]/)
        : destination && validateDestinationWithoutOrganization(destination)
            ? [organization, ...destination.split('@')]
            : [organization];
}
exports.getDestinationProps = getDestinationProps;
const transformPush = (callback) => (_a) => {
    var { maybeEntrypointOrAliasOrDestination, maybeDestination, maybeBranchName, branch } = _a, rest = __rest(_a, ["maybeEntrypointOrAliasOrDestination", "maybeDestination", "maybeBranchName", "branch"]);
    if (!!maybeBranchName) {
        process.stderr.write(colorette_1.yellow('Deprecation warning: Do not use the third parameter as a branch name. Please use a separate --branch option instead.'));
    }
    const entrypoint = maybeDestination ? maybeEntrypointOrAliasOrDestination : undefined;
    const destination = maybeDestination || maybeEntrypointOrAliasOrDestination;
    return callback(Object.assign(Object.assign({}, rest), { destination,
        entrypoint, branchName: branch !== null && branch !== void 0 ? branch : maybeBranchName }));
};
exports.transformPush = transformPush;
function getApiEntrypoint({ name, version, config: { apis }, }) {
    const api = (apis === null || apis === void 0 ? void 0 : apis[`${name}@${version}`]) || (version === DEFAULT_VERSION && (apis === null || apis === void 0 ? void 0 : apis[name]));
    return api === null || api === void 0 ? void 0 : api.root;
}
exports.getApiEntrypoint = getApiEntrypoint;
function uploadFileToS3(url, filePathOrBuffer) {
    const fileSizeInBytes = typeof filePathOrBuffer === 'string'
        ? fs.statSync(filePathOrBuffer).size
        : filePathOrBuffer.byteLength;
    let readStream = typeof filePathOrBuffer === 'string' ? fs.createReadStream(filePathOrBuffer) : filePathOrBuffer;
    return node_fetch_1.default(url, {
        method: 'PUT',
        headers: {
            'Content-Length': fileSizeInBytes.toString(),
        },
        body: readStream,
    });
}
